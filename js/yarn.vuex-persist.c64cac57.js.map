{"version":3,"sources":["webpack:///./node_modules/vuex-persist/dist/esm/index.js"],"names":["MockStorage","Object","keys","this","length","index","key","data","toString","SimplePromiseQueue","_queue","_flushing","promise","push","Promise","resolve","flushQueue","chain","nextTask","shift","then","merge","into","from","FlattedJSON","JSON","VuexPersistence","options","_mutex","subscriber","store","handler","subscribe","subscribed","supportCircular","storage","window","localStorage","reducer","modules","state","reduce","a","i","filter","mutation","strictMode","RESTORE_MUTATION","savedState","mergedState","propertyName","_vm","$set","asyncStorage","restoreState","getItem","value","parse","saveState","setItem","stringify","plugin","restored","commit","replaceState","enqueue"],"mappings":"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","file":"js/yarn.vuex-persist.c64cac57.js","sourcesContent":["import lodashMerge from 'lodash.merge';\n\n/**\r\n * Created by championswimmer on 22/07/17.\r\n */\r\nlet MockStorage;\r\n// @ts-ignore\r\n{\r\n    MockStorage = class {\r\n        get length() {\r\n            return Object.keys(this).length;\r\n        }\r\n        key(index) {\r\n            return Object.keys(this)[index];\r\n        }\r\n        setItem(key, data) {\r\n            this[key] = data.toString();\r\n        }\r\n        getItem(key) {\r\n            return this[key];\r\n        }\r\n        removeItem(key) {\r\n            delete this[key];\r\n        }\r\n        clear() {\r\n            for (const key of Object.keys(this)) {\r\n                delete this[key];\r\n            }\r\n        }\r\n    };\r\n}\n\n// tslint:disable: variable-name\r\nclass SimplePromiseQueue {\r\n    constructor() {\r\n        this._queue = [];\r\n        this._flushing = false;\r\n    }\r\n    enqueue(promise) {\r\n        this._queue.push(promise);\r\n        if (!this._flushing) {\r\n            return this.flushQueue();\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    flushQueue() {\r\n        this._flushing = true;\r\n        const chain = () => {\r\n            const nextTask = this._queue.shift();\r\n            if (nextTask) {\r\n                return nextTask.then(chain);\r\n            }\r\n            else {\r\n                this._flushing = false;\r\n            }\r\n        };\r\n        return Promise.resolve(chain());\r\n    }\r\n}\n\nfunction merge(into, from) {\r\n    return lodashMerge({}, into, from);\r\n}\n\nlet FlattedJSON = JSON;\r\n/**\r\n * A class that implements the vuex persistence.\r\n * @type S type of the 'state' inside the store (default: any)\r\n */\r\nclass VuexPersistence {\r\n    /**\r\n     * Create a {@link VuexPersistence} object.\r\n     * Use the <code>plugin</code> function of this class as a\r\n     * Vuex plugin.\r\n     * @param {PersistOptions} options\r\n     */\r\n    constructor(options) {\r\n        // tslint:disable-next-line:variable-name\r\n        this._mutex = new SimplePromiseQueue();\r\n        /**\r\n         * Creates a subscriber on the store. automatically is used\r\n         * when this is used a vuex plugin. Not for manual usage.\r\n         * @param store\r\n         */\r\n        this.subscriber = (store) => (handler) => store.subscribe(handler);\r\n        if (typeof options === 'undefined')\r\n            options = {};\r\n        this.key = ((options.key != null) ? options.key : 'vuex');\r\n        this.subscribed = false;\r\n        this.supportCircular = options.supportCircular || false;\r\n        if (this.supportCircular) {\r\n            FlattedJSON = require('flatted');\r\n        }\r\n        // @ts-ignore\r\n        if (process.env.NODE_ENV === 'production') {\r\n            this.storage = options.storage || window.localStorage;\r\n        }\r\n        else {\r\n            // @ts-ignore\r\n            {\r\n                this.storage = options.storage || (typeof window !== 'undefined' ? window.localStorage : new MockStorage());\r\n            }\r\n        }\r\n        /**\r\n         * How this works is -\r\n         *  1. If there is options.reducer function, we use that, if not;\r\n         *  2. We check options.modules;\r\n         *    1. If there is no options.modules array, we use entire state in reducer\r\n         *    2. Otherwise, we create a reducer that merges all those state modules that are\r\n         *        defined in the options.modules[] array\r\n         * @type {((state: S) => {}) | ((state: S) => S) | ((state: any) => {})}\r\n         */\r\n        this.reducer = ((options.reducer != null)\r\n            ? options.reducer\r\n            : ((options.modules == null)\r\n                ? ((state) => state)\r\n                : ((state) => options.modules.reduce((a, i) => merge(a, { [i]: state[i] }), { /* start empty accumulator*/}))));\r\n        this.filter = options.filter || ((mutation) => true);\r\n        this.strictMode = options.strictMode || false;\r\n        this.RESTORE_MUTATION = function RESTORE_MUTATION(state, savedState) {\r\n            const mergedState = merge(state, savedState || {});\r\n            for (const propertyName of Object.keys(mergedState)) {\r\n                this._vm.$set(state, propertyName, mergedState[propertyName]);\r\n            }\r\n        };\r\n        this.asyncStorage = options.asyncStorage || false;\r\n        if (this.asyncStorage) {\r\n            /**\r\n             * Async {@link #VuexPersistence.restoreState} implementation\r\n             * @type {((key: string, storage?: Storage) =>\r\n             *      (Promise<S> | S)) | ((key: string, storage: AsyncStorage) => Promise<any>)}\r\n             */\r\n            this.restoreState = ((options.restoreState != null)\r\n                ? options.restoreState\r\n                : ((key, storage) => (storage).getItem(key)\r\n                    .then((value) => typeof value === 'string' // If string, parse, or else, just return\r\n                    ? (this.supportCircular\r\n                        ? FlattedJSON.parse(value || '{}')\r\n                        : JSON.parse(value || '{}'))\r\n                    : (value || {}))));\r\n            /**\r\n             * Async {@link #VuexPersistence.saveState} implementation\r\n             * @type {((key: string, state: {}, storage?: Storage) =>\r\n             *    (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n             */\r\n            this.saveState = ((options.saveState != null)\r\n                ? options.saveState\r\n                : ((key, state, storage) => (storage).setItem(key, // Second argument is state _object_ if asyc storage, stringified otherwise\r\n                // do not stringify the state if the storage type is async\r\n                (this.asyncStorage\r\n                    ? merge({}, state || {})\r\n                    : (this.supportCircular\r\n                        ? FlattedJSON.stringify(state)\r\n                        : JSON.stringify(state))))));\r\n            /**\r\n             * Async version of plugin\r\n             * @param {Store<S>} store\r\n             */\r\n            this.plugin = (store) => {\r\n                /**\r\n                 * For async stores, we're capturing the Promise returned\r\n                 * by the `restoreState()` function in a `restored` property\r\n                 * on the store itself. This would allow app developers to\r\n                 * determine when and if the store's state has indeed been\r\n                 * refreshed. This approach was suggested by GitHub user @hotdogee.\r\n                 * See https://github.com/championswimmer/vuex-persist/pull/118#issuecomment-500914963\r\n                 * @since 2.1.0\r\n                 */\r\n                store.restored = (this.restoreState(this.key, this.storage)).then((savedState) => {\r\n                    /**\r\n                     * If in strict mode, do only via mutation\r\n                     */\r\n                    if (this.strictMode) {\r\n                        store.commit('RESTORE_MUTATION', savedState);\r\n                    }\r\n                    else {\r\n                        store.replaceState(merge(store.state, savedState || {}));\r\n                    }\r\n                    this.subscriber(store)((mutation, state) => {\r\n                        if (this.filter(mutation)) {\r\n                            this._mutex.enqueue(this.saveState(this.key, this.reducer(state), this.storage));\r\n                        }\r\n                    });\r\n                    this.subscribed = true;\r\n                });\r\n            };\r\n        }\r\n        else {\r\n            /**\r\n             * Sync {@link #VuexPersistence.restoreState} implementation\r\n             * @type {((key: string, storage?: Storage) =>\r\n             *    (Promise<S> | S)) | ((key: string, storage: Storage) => (any | string | {}))}\r\n             */\r\n            this.restoreState = ((options.restoreState != null)\r\n                ? options.restoreState\r\n                : ((key, storage) => {\r\n                    const value = (storage).getItem(key);\r\n                    if (typeof value === 'string') { // If string, parse, or else, just return\r\n                        return (this.supportCircular\r\n                            ? FlattedJSON.parse(value || '{}')\r\n                            : JSON.parse(value || '{}'));\r\n                    }\r\n                    else {\r\n                        return (value || {});\r\n                    }\r\n                }));\r\n            /**\r\n             * Sync {@link #VuexPersistence.saveState} implementation\r\n             * @type {((key: string, state: {}, storage?: Storage) =>\r\n             *     (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n             */\r\n            this.saveState = ((options.saveState != null)\r\n                ? options.saveState\r\n                : ((key, state, storage) => (storage).setItem(key, // Second argument is state _object_ if localforage, stringified otherwise\r\n                (this.supportCircular\r\n                    ? FlattedJSON.stringify(state)\r\n                    : JSON.stringify(state)))));\r\n            /**\r\n             * Sync version of plugin\r\n             * @param {Store<S>} store\r\n             */\r\n            this.plugin = (store) => {\r\n                const savedState = this.restoreState(this.key, this.storage);\r\n                if (this.strictMode) {\r\n                    store.commit('RESTORE_MUTATION', savedState);\r\n                }\r\n                else {\r\n                    store.replaceState(merge(store.state, savedState || {}));\r\n                }\r\n                this.subscriber(store)((mutation, state) => {\r\n                    if (this.filter(mutation)) {\r\n                        this.saveState(this.key, this.reducer(state), this.storage);\r\n                    }\r\n                });\r\n                this.subscribed = true;\r\n            };\r\n        }\r\n    }\r\n}\n\nexport default VuexPersistence;\nexport { MockStorage, VuexPersistence };\n//# sourceMappingURL=index.js.map\n"],"sourceRoot":""}