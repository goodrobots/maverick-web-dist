{"version":3,"sources":["webpack:///./node_modules/optimism/lib/bundle.esm.js"],"names":["defaultDispose","Cache","max","dispose","Infinity","this","map","Map","newest","oldest","prototype","has","key","get","entry","getEntry","value","older","newer","set","clean","size","delete","parentEntrySlot","reusableEmptyArray","emptySetPool","POOL_TARGET_SIZE","assert","condition","optionalMessage","Error","valueIs","a","b","len","length","valueGet","valueCopy","slice","Entry","fn","args","parents","Set","childValues","dirtyChildren","dirty","recomputing","count","recompute","rememberParent","maybeReportOrphan","mightBeDirty","reallyRecompute","setDirty","reportDirty","maybeUnsubscribe","_this","forgetChildren","forEach","parent","forgetChild","child","getValue","add","reportDirtyChild","reportCleanChild","originalChildren","withValue","recomputeNewValue","maybeSubscribe","setClean","apply","e","reportClean","pop","childValue","removeDirtyChild","dc","push","reportOrphan","children","_value","subscribe","unsubscribe","KeyTrie","weakness","lookup","array","_i","arguments","lookupArray","node","getChildTrie","data","Object","create","isObjRef","weak","WeakMap","strong","keyTrie","defaultMakeCacheKey","caches","wrap","originalFunction","options","cache","Math","pow","disposable","makeCacheKey","optimistic","hasValue","Array","call","clear"],"mappings":"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","file":"js/yarn.optimism.15a6641c.js","sourcesContent":["import { Slot } from '@wry/context';\nexport { asyncFromGen, bind as bindContext, noContext, setTimeout } from '@wry/context';\n\nfunction defaultDispose() { }\r\nvar Cache = /** @class */ (function () {\r\n    function Cache(max, dispose) {\r\n        if (max === void 0) { max = Infinity; }\r\n        if (dispose === void 0) { dispose = defaultDispose; }\r\n        this.max = max;\r\n        this.dispose = dispose;\r\n        this.map = new Map();\r\n        this.newest = null;\r\n        this.oldest = null;\r\n    }\r\n    Cache.prototype.has = function (key) {\r\n        return this.map.has(key);\r\n    };\r\n    Cache.prototype.get = function (key) {\r\n        var entry = this.getEntry(key);\r\n        return entry && entry.value;\r\n    };\r\n    Cache.prototype.getEntry = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry && entry !== this.newest) {\r\n            var older = entry.older, newer = entry.newer;\r\n            if (newer) {\r\n                newer.older = older;\r\n            }\r\n            if (older) {\r\n                older.newer = newer;\r\n            }\r\n            entry.older = this.newest;\r\n            entry.older.newer = entry;\r\n            entry.newer = null;\r\n            this.newest = entry;\r\n            if (entry === this.oldest) {\r\n                this.oldest = newer;\r\n            }\r\n        }\r\n        return entry;\r\n    };\r\n    Cache.prototype.set = function (key, value) {\r\n        var entry = this.getEntry(key);\r\n        if (entry) {\r\n            return entry.value = value;\r\n        }\r\n        entry = {\r\n            key: key,\r\n            value: value,\r\n            newer: null,\r\n            older: this.newest\r\n        };\r\n        if (this.newest) {\r\n            this.newest.newer = entry;\r\n        }\r\n        this.newest = entry;\r\n        this.oldest = this.oldest || entry;\r\n        this.map.set(key, entry);\r\n        return entry.value;\r\n    };\r\n    Cache.prototype.clean = function () {\r\n        while (this.oldest && this.map.size > this.max) {\r\n            this.delete(this.oldest.key);\r\n        }\r\n    };\r\n    Cache.prototype.delete = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry) {\r\n            if (entry === this.newest) {\r\n                this.newest = entry.older;\r\n            }\r\n            if (entry === this.oldest) {\r\n                this.oldest = entry.newer;\r\n            }\r\n            if (entry.newer) {\r\n                entry.newer.older = entry.older;\r\n            }\r\n            if (entry.older) {\r\n                entry.older.newer = entry.newer;\r\n            }\r\n            this.map.delete(key);\r\n            this.dispose(entry.value, key);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    return Cache;\r\n}());\n\nvar parentEntrySlot = new Slot();\n\nvar reusableEmptyArray = [];\r\nvar emptySetPool = [];\r\nvar POOL_TARGET_SIZE = 100;\r\n// Since this package might be used browsers, we should avoid using the\r\n// Node built-in assert module.\r\nfunction assert(condition, optionalMessage) {\r\n    if (!condition) {\r\n        throw new Error(optionalMessage || \"assertion failure\");\r\n    }\r\n}\r\nfunction valueIs(a, b) {\r\n    var len = a.length;\r\n    return (\r\n    // Unknown values are not equal to each other.\r\n    len > 0 &&\r\n        // Both values must be ordinary (or both exceptional) to be equal.\r\n        len === b.length &&\r\n        // The underlying value or exception must be the same.\r\n        a[len - 1] === b[len - 1]);\r\n}\r\nfunction valueGet(value) {\r\n    switch (value.length) {\r\n        case 0: throw new Error(\"unknown value\");\r\n        case 1: return value[0];\r\n        case 2: throw value[1];\r\n    }\r\n}\r\nfunction valueCopy(value) {\r\n    return value.slice(0);\r\n}\r\nvar Entry = /** @class */ (function () {\r\n    function Entry(fn, args) {\r\n        this.fn = fn;\r\n        this.args = args;\r\n        this.parents = new Set();\r\n        this.childValues = new Map();\r\n        // When this Entry has children that are dirty, this property becomes\r\n        // a Set containing other Entry objects, borrowed from emptySetPool.\r\n        // When the set becomes empty, it gets recycled back to emptySetPool.\r\n        this.dirtyChildren = null;\r\n        this.dirty = true;\r\n        this.recomputing = false;\r\n        this.value = [];\r\n        ++Entry.count;\r\n    }\r\n    // This is the most important method of the Entry API, because it\r\n    // determines whether the cached this.value can be returned immediately,\r\n    // or must be recomputed. The overall performance of the caching system\r\n    // depends on the truth of the following observations: (1) this.dirty is\r\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\r\n    // (3) valueGet(this.value) is usually returned without recomputation.\r\n    Entry.prototype.recompute = function () {\r\n        assert(!this.recomputing, \"already recomputing\");\r\n        if (!rememberParent(this) && maybeReportOrphan(this)) {\r\n            // The recipient of the entry.reportOrphan callback decided to dispose\r\n            // of this orphan entry by calling entry.dispose(), so we don't need to\r\n            // (and should not) proceed with the recomputation.\r\n            return void 0;\r\n        }\r\n        return mightBeDirty(this)\r\n            ? reallyRecompute(this)\r\n            : valueGet(this.value);\r\n    };\r\n    Entry.prototype.setDirty = function () {\r\n        if (this.dirty)\r\n            return;\r\n        this.dirty = true;\r\n        this.value.length = 0;\r\n        reportDirty(this);\r\n        // We can go ahead and unsubscribe here, since any further dirty\r\n        // notifications we receive will be redundant, and unsubscribing may\r\n        // free up some resources, e.g. file watchers.\r\n        maybeUnsubscribe(this);\r\n    };\r\n    Entry.prototype.dispose = function () {\r\n        var _this = this;\r\n        forgetChildren(this).forEach(maybeReportOrphan);\r\n        maybeUnsubscribe(this);\r\n        // Because this entry has been kicked out of the cache (in index.js),\r\n        // we've lost the ability to find out if/when this entry becomes dirty,\r\n        // whether that happens through a subscription, because of a direct call\r\n        // to entry.setDirty(), or because one of its children becomes dirty.\r\n        // Because of this loss of future information, we have to assume the\r\n        // worst (that this entry might have become dirty very soon), so we must\r\n        // immediately mark this entry's parents as dirty. Normally we could\r\n        // just call entry.setDirty() rather than calling parent.setDirty() for\r\n        // each parent, but that would leave this entry in parent.childValues\r\n        // and parent.dirtyChildren, which would prevent the child from being\r\n        // truly forgotten.\r\n        this.parents.forEach(function (parent) {\r\n            parent.setDirty();\r\n            forgetChild(parent, _this);\r\n        });\r\n    };\r\n    Entry.count = 0;\r\n    return Entry;\r\n}());\r\nfunction rememberParent(child) {\r\n    var parent = parentEntrySlot.getValue();\r\n    if (parent) {\r\n        child.parents.add(parent);\r\n        if (!parent.childValues.has(child)) {\r\n            parent.childValues.set(child, []);\r\n        }\r\n        if (mightBeDirty(child)) {\r\n            reportDirtyChild(parent, child);\r\n        }\r\n        else {\r\n            reportCleanChild(parent, child);\r\n        }\r\n        return parent;\r\n    }\r\n}\r\nfunction reallyRecompute(entry) {\r\n    // Since this recomputation is likely to re-remember some of this\r\n    // entry's children, we forget our children here but do not call\r\n    // maybeReportOrphan until after the recomputation finishes.\r\n    var originalChildren = forgetChildren(entry);\r\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\r\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\r\n    if (maybeSubscribe(entry)) {\r\n        // If we successfully recomputed entry.value and did not fail to\r\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\r\n        setClean(entry);\r\n    }\r\n    // Now that we've had a chance to re-remember any children that were\r\n    // involved in the recomputation, we can safely report any orphan\r\n    // children that remain.\r\n    originalChildren.forEach(maybeReportOrphan);\r\n    return valueGet(entry.value);\r\n}\r\nfunction recomputeNewValue(entry) {\r\n    entry.recomputing = true;\r\n    // Set entry.value as unknown.\r\n    entry.value.length = 0;\r\n    try {\r\n        // If entry.fn succeeds, entry.value will become a normal Value.\r\n        entry.value[0] = entry.fn.apply(null, entry.args);\r\n    }\r\n    catch (e) {\r\n        // If entry.fn throws, entry.value will become exceptional.\r\n        entry.value[1] = e;\r\n    }\r\n    // Either way, this line is always reached.\r\n    entry.recomputing = false;\r\n}\r\nfunction mightBeDirty(entry) {\r\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\r\n}\r\nfunction setClean(entry) {\r\n    entry.dirty = false;\r\n    if (mightBeDirty(entry)) {\r\n        // This Entry may still have dirty children, in which case we can't\r\n        // let our parents know we're clean just yet.\r\n        return;\r\n    }\r\n    reportClean(entry);\r\n}\r\nfunction reportDirty(child) {\r\n    child.parents.forEach(function (parent) { return reportDirtyChild(parent, child); });\r\n}\r\nfunction reportClean(child) {\r\n    child.parents.forEach(function (parent) { return reportCleanChild(parent, child); });\r\n}\r\n// Let a parent Entry know that one of its children may be dirty.\r\nfunction reportDirtyChild(parent, child) {\r\n    // Must have called rememberParent(child) before calling\r\n    // reportDirtyChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(mightBeDirty(child));\r\n    if (!parent.dirtyChildren) {\r\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\r\n    }\r\n    else if (parent.dirtyChildren.has(child)) {\r\n        // If we already know this child is dirty, then we must have already\r\n        // informed our own parents that we are dirty, so we can terminate\r\n        // the recursion early.\r\n        return;\r\n    }\r\n    parent.dirtyChildren.add(child);\r\n    reportDirty(parent);\r\n}\r\n// Let a parent Entry know that one of its children is no longer dirty.\r\nfunction reportCleanChild(parent, child) {\r\n    // Must have called rememberChild(child) before calling\r\n    // reportCleanChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(!mightBeDirty(child));\r\n    var childValue = parent.childValues.get(child);\r\n    if (childValue.length === 0) {\r\n        parent.childValues.set(child, valueCopy(child.value));\r\n    }\r\n    else if (!valueIs(childValue, child.value)) {\r\n        parent.setDirty();\r\n    }\r\n    removeDirtyChild(parent, child);\r\n    if (mightBeDirty(parent)) {\r\n        return;\r\n    }\r\n    reportClean(parent);\r\n}\r\nfunction removeDirtyChild(parent, child) {\r\n    var dc = parent.dirtyChildren;\r\n    if (dc) {\r\n        dc.delete(child);\r\n        if (dc.size === 0) {\r\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\r\n                emptySetPool.push(dc);\r\n            }\r\n            parent.dirtyChildren = null;\r\n        }\r\n    }\r\n}\r\n// If the given entry has a reportOrphan method, and no remaining parents,\r\n// call entry.reportOrphan and return true iff it returns true. The\r\n// reportOrphan function should return true to indicate entry.dispose()\r\n// has been called, and the entry has been removed from any other caches\r\n// (see index.js for the only current example).\r\nfunction maybeReportOrphan(entry) {\r\n    return entry.parents.size === 0 &&\r\n        typeof entry.reportOrphan === \"function\" &&\r\n        entry.reportOrphan() === true;\r\n}\r\n// Removes all children from this entry and returns an array of the\r\n// removed children.\r\nfunction forgetChildren(parent) {\r\n    var children = reusableEmptyArray;\r\n    if (parent.childValues.size > 0) {\r\n        children = [];\r\n        parent.childValues.forEach(function (_value, child) {\r\n            forgetChild(parent, child);\r\n            children.push(child);\r\n        });\r\n    }\r\n    // After we forget all our children, this.dirtyChildren must be empty\r\n    // and therefore must have been reset to null.\r\n    assert(parent.dirtyChildren === null);\r\n    return children;\r\n}\r\nfunction forgetChild(parent, child) {\r\n    child.parents.delete(parent);\r\n    parent.childValues.delete(child);\r\n    removeDirtyChild(parent, child);\r\n}\r\nfunction maybeSubscribe(entry) {\r\n    if (typeof entry.subscribe === \"function\") {\r\n        try {\r\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\r\n            entry.unsubscribe = entry.subscribe.apply(null, entry.args);\r\n        }\r\n        catch (e) {\r\n            // If this Entry has a subscribe function and it threw an exception\r\n            // (or an unsubscribe function it previously returned now throws),\r\n            // return false to indicate that we were not able to subscribe (or\r\n            // unsubscribe), and this Entry should remain dirty.\r\n            entry.setDirty();\r\n            return false;\r\n        }\r\n    }\r\n    // Returning true indicates either that there was no entry.subscribe\r\n    // function or that it succeeded.\r\n    return true;\r\n}\r\nfunction maybeUnsubscribe(entry) {\r\n    var unsubscribe = entry.unsubscribe;\r\n    if (typeof unsubscribe === \"function\") {\r\n        entry.unsubscribe = void 0;\r\n        unsubscribe();\r\n    }\r\n}\n\n// A trie data structure that holds object keys weakly, yet can also hold\r\n// non-object keys, unlike the native `WeakMap`.\r\nvar KeyTrie = /** @class */ (function () {\r\n    function KeyTrie(weakness) {\r\n        this.weakness = weakness;\r\n    }\r\n    KeyTrie.prototype.lookup = function () {\r\n        var array = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            array[_i] = arguments[_i];\r\n        }\r\n        return this.lookupArray(array);\r\n    };\r\n    KeyTrie.prototype.lookupArray = function (array) {\r\n        var node = this;\r\n        array.forEach(function (key) { return node = node.getChildTrie(key); });\r\n        return node.data || (node.data = Object.create(null));\r\n    };\r\n    KeyTrie.prototype.getChildTrie = function (key) {\r\n        var map = this.weakness && isObjRef(key)\r\n            ? this.weak || (this.weak = new WeakMap())\r\n            : this.strong || (this.strong = new Map());\r\n        var child = map.get(key);\r\n        if (!child)\r\n            map.set(key, child = new KeyTrie(this.weakness));\r\n        return child;\r\n    };\r\n    return KeyTrie;\r\n}());\r\nfunction isObjRef(value) {\r\n    switch (typeof value) {\r\n        case \"object\":\r\n            if (value === null)\r\n                break;\r\n        // Fall through to return true...\r\n        case \"function\":\r\n            return true;\r\n    }\r\n    return false;\r\n}\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\r\n// a unique object for any shallow-identical list of arguments. If you need\r\n// to implement a custom makeCacheKey function, you may find it helpful to\r\n// delegate the final work to defaultMakeCacheKey, which is why we export it\r\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\r\n// does not support WeakMap, or you have the ability to return a string key.\r\n// In those cases, just write your own custom makeCacheKey functions.\r\nvar keyTrie = new KeyTrie(typeof WeakMap === \"function\");\r\nfunction defaultMakeCacheKey() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return keyTrie.lookupArray(args);\r\n}\r\nvar caches = new Set();\r\nfunction wrap(originalFunction, options) {\r\n    if (options === void 0) { options = Object.create(null); }\r\n    var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });\r\n    var disposable = !!options.disposable;\r\n    var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;\r\n    function optimistic() {\r\n        if (disposable && !parentEntrySlot.hasValue()) {\r\n            // If there's no current parent computation, and this wrapped\r\n            // function is disposable (meaning we don't care about entry.value,\r\n            // just dependency tracking), then we can short-cut everything else\r\n            // in this function, because entry.recompute() is going to recycle\r\n            // the entry object without recomputing anything, anyway.\r\n            return void 0;\r\n        }\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        if (key === void 0) {\r\n            return originalFunction.apply(null, arguments);\r\n        }\r\n        var args = Array.prototype.slice.call(arguments);\r\n        var entry = cache.get(key);\r\n        if (entry) {\r\n            entry.args = args;\r\n        }\r\n        else {\r\n            entry = new Entry(originalFunction, args);\r\n            cache.set(key, entry);\r\n            entry.subscribe = options.subscribe;\r\n            if (disposable) {\r\n                entry.reportOrphan = function () { return cache.delete(key); };\r\n            }\r\n        }\r\n        var value = entry.recompute();\r\n        // Move this entry to the front of the least-recently used queue,\r\n        // since we just finished computing its value.\r\n        cache.set(key, entry);\r\n        caches.add(cache);\r\n        // Clean up any excess entries in the cache, but only if there is no\r\n        // active parent entry, meaning we're not in the middle of a larger\r\n        // computation that might be flummoxed by the cleaning.\r\n        if (!parentEntrySlot.hasValue()) {\r\n            caches.forEach(function (cache) { return cache.clean(); });\r\n            caches.clear();\r\n        }\r\n        // If options.disposable is truthy, the caller of wrap is telling us\r\n        // they don't care about the result of entry.recompute(), so we should\r\n        // avoid returning the value, so it won't be accidentally used.\r\n        return disposable ? void 0 : value;\r\n    }\r\n    optimistic.dirty = function () {\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        var child = key !== void 0 && cache.get(key);\r\n        if (child) {\r\n            child.setDirty();\r\n        }\r\n    };\r\n    return optimistic;\r\n}\n\nexport { KeyTrie, defaultMakeCacheKey, wrap };\n//# sourceMappingURL=bundle.esm.js.map\n"],"sourceRoot":""}